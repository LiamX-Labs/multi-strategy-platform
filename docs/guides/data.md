This guide outlines the critical inputs and data flows required to accurately track your trading strategies' performance and manage position lifecycles in real-time.SECTION 1: KEY INPUTS & METRICS FOR PERFORMANCE TRACKINGTo track performance, you must listen for real-time events. Polling the REST API is too slow. Your system must be connected to the Bybit Private WebSocket (v5) and listen for these three topics.1. Core Data Sources (Bybit WebSocket Topics)execution (The "Performance" Stream)WHAT IT IS: This is your "book of record" for performance. It sends a message every single time one of your orders is filled (a "trade" or "execution" occurs).WHY YOU NEED IT: This is the only place you get the exact execPrice (fill price), execQty (fill quantity), and commission (fees paid). You cannot perform accurate PnL analysis without this.order (The "Lifecycle" Stream)WHAT IT IS: This stream sends an update for every change in an order's lifecycle: New, PartiallyFilled, Filled, Canceled, Rejected.WHY YOU NEED IT: This is how you track the intent of your system and confirm your orders are active or closed.position (The "Reconciliation" Stream)WHAT IT IS: This sends a complete update of your entire position (e.g., total size, entry price, margin) whenever it changes.WHY YOU NEED IT: This is your "source of truth" from the exchange. Your system's internal state (in Redis) must be synced to this message to prevent "drift."2. The Single Most Important Input (Your "Why" Tag)client_order_id (or clOrdId)When you send an order to Bybit, you can attach your own custom ID. This is the only way to link a specific trade back to the strategy logic that created it. Your system must be programmed to send a descriptive clOrdId with every order.Entry Example: clOrdId: "bot_1:entry:1678886400"Exit Example (Trailing Stop): clOrdId: "bot_1:trailing_stop:1678886600"Exit Example (Manual): clOrdId: "manual_override:close:1678886700"When the execution stream sends a fill, it will include this ID, telling you why the trade happened.3. Key Metrics to Store (For Performance Analysis)Your WebSocket listener must capture these fields from every execution message and save them to your Postgres database (in your fills table). This is the raw data for all performance analysis.MetricFrom execution StreamPurpose (How it's Used)bot_id(Parsed from clOrdId)The most important metric for grouping trades by strategy.close_reason(Parsed from clOrdId)Solves your tracking problem (e.g., "trailing_stop", "manual", "take_profit").Entry/Exit TimeexecTimeThe exact millisecond timestamp of the trade.Entry/Exit PriceexecPriceThe price at which the trade was executed.cl_ord_idclOrdIdYour custom ID for debugging and linking.order_idorderIdThe unique ID from Bybit.symbolsymbole.g., BTCUSDTsidesideBuy or Sell. This determines if the fill is an "Entry" or "Exit".exec_qtyexecQtyThe amount of the asset that was actually traded.commissionexecFeeThe fee paid for this trade. Crucial for net PnL.SECTION 2: DATABASE WORKFLOW EXPLAINEDHere is how your three databases work together to create a robust, real-time tracking system.1. InfluxDB (The "Context" or "Market Archive")Role: Stores market data, not your trades.What it does: Your data_recorder container listens to the Public WebSocket kline stream and dumps all candle data (OHLCV) into InfluxDB.How it's used: InfluxDB knows what the market was doing at any given time. It does not know about your trades. Its job is to provide the market price chart in Grafana. You can then plot your "Entry/Exit" fills (from Postgres) on top of this chart to see your execution in context.Analogy: It's the "map" of the road.2. PostgreSQL (The "Ledger" or "Permanent Record")Role: Stores your performance history. This is your "book of truth" for PnL.What it does: Your WebSocket listener (in your bot or a separate service) listens to the Private execution stream. When a fill occurs, it grabs the metrics (from the table above) and inserts them as a new row in your fills table.How it handles "Entry/Exit Price":Postgres does not store "a position." It stores a list of fills.When your bot buys 1.0 BTC, it's a fill with side="Buy", execPrice="60000". This is your Entry Fill.When your bot sells 1.0 BTC, it's a fill with side="Sell", execPrice="61000". This is your Exit Fill.How it's used: To get your performance, you run a SQL query.Grafana queries Postgres: SELECT * FROM fills WHERE bot_id = 'bot_1' to get all trades.Telegram queries Postgres: SELECT SUM(commission) FROM fills WHERE bot_id = 'bot_1' to get total fees.A full PnL analysis is a query that groups all "Buy" and "Sell" fills for a given bot and symbol to calculate the net profit or loss.Analogy: It's the "trip logbook," recording every time you got on or off the highway and how much you paid in tolls.3. Redis (The "Live State" or "Whiteboard")Role: Answers the question, "What is my position right now?"What it does: It stores the current state of your system in memory for microsecond access. It knows nothing about your past performance.How it's used: This is the glue that connects your live bot, Postgres, and the position stream.End-to-End Workflow: How a Position is Opened and ClosedThis is the complete data flow for a single trade.Phase 1: Opening a PositionBot bot_1 is flat. Redis reflects this:GET "bot_1:position:BTCUSDT" returns "0".Bot bot_1 logic is true. It places a Buy order with clOrdId: "bot_1:entry:123".execution stream sends a fill message: side="Buy", execPrice="60000", execQty="1.0", clOrdId="bot_1:entry:123".Listener saves to Postgres: A new row is added to the fills table with this data. Your Entry Price and Entry Time are now permanently recorded.position stream sends an update: symbol="BTCUSDT", size="1.0", side="Buy".Listener updates Redis: The system's live state is updated:SET "bot_1:position:BTCUSDT" "1.0"Phase 2: The System is LiveYour bot_1 loop runs. It checks Redis (GET "bot_1:position:BTCUSDT") and sees "1.0", so it knows to manage the open trade.Your Grafana dashboard reads Redis and shows a "Live Position" panel with "1.0".Your Telegram bot (/status command) reads Redis and reports bot_1 (BTCUSDT): 1.0.Phase 3: Closing a Position (The "Immediate Detection")A trailing stop is hit on Bybit. This was an order with clOrdId: "bot_1:ts:456".IMMEDIATELY (within milliseconds), your execution stream sends a fill message: side="Sell", execPrice="60500", execQty="1.0", clOrdId="bot_1:ts:456".Listener saves to Postgres: A new row is added to the fills table. Your Exit Price, Exit Time, and Close Reason ("trailing_stop" parsed from the clOrdId) are now permanently recorded.position stream sends an update: symbol="BTCUSDT", size="0", side="None".Listener updates Redis: The system's live state is instantly updated:SET "bot_1:position:BTCUSDT" "0"Result:The instant the position is closed, Redis is updated to "0". On its very next loop (milliseconds later), your bot_1 sees it's flat and will look for a new entry. Your Grafana and Telegram UIs also instantly reflect that the position is closed. Your Postgres database now has the complete, permanent record of the entire trade (entry and exit) for PnL analysis.